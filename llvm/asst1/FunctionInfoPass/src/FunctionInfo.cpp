//// Created by 骆驼 on 2020/7/14.//#include "llvm/Pass.h"#include "llvm/IR/Function.h"#include "llvm/Support/raw_ostream.h"#include "llvm/IR/Module.h"#include <ostream>#include <fstream>#include <iostream>using namespace llvm;namespace {    class FunctionInfo : public ModulePass {        // Output the function information to standard out.        void printFunctionInfo(Module& M) {            errs() << "Module " << M.getModuleIdentifier().c_str() << "\n";            errs() << "Name,\tArgs,\tCalls,\tBlocks,\tInsns\n";            // TODO: Print out information about each function in this format.            size_t instruction_count = 0;            int name_count = M.size();            Module::iterator MI = M.begin();            while (name_count--) {                errs() << MI->getName() <<",\t";                errs() << MI->arg_size() << ",\t" << MI->getNumUses() << ",\t" <<  MI->getBasicBlockList().size()<<"\t";                for(auto &BB : *MI){                    instruction_count += BB.getInstList().size();                }                errs() << instruction_count << "\n";                instruction_count = 0;                MI++;            }        }    public:        static char ID;        FunctionInfo() : ModulePass(ID) { }        ~FunctionInfo() { }        // We don't modify the program, so we preserve all analyses        virtual void getAnalysisUsage(AnalysisUsage &AU) const {            AU.setPreservesAll();        }        virtual bool runOnFunction(Function &F) {            // TODO: implement this.            // 得到方法的名字。            errs() << F.getName() << "     ";            // 得到方法参数的个数。            errs() << F.arg_size() << "    ";            // 得到被调用的次数。            errs() << F.getNumUses() << "   ";            // 得到基础块数。            errs() << F.getBasicBlockList().size() << "    ";            // 得到指令个数。（IR 代码行）            int InstrSize = 0;            for(auto &BB : F){                InstrSize += BB.getInstList().size();                // 中间有多少行 IR 代码//                for (BasicBlock::iterator i = BB.begin(), e = BB.end(); i != e; ++i)  //获取每个basic block中的instruction//                {//                    errs() << *i << " |||| ";//                }            }            errs()  << InstrSize << "    " << "\n";            return false;        }        virtual bool runOnModule(Module& M) {            errs() << "Function Information Pass\n"; // TODO: remove this.//            for (Module::iterator MI = M.begin(), ME = M.end(); MI != ME; ++MI) {//                runOnFunction(*MI);//            }            // TODO: uncomment this.            printFunctionInfo(M);            return false;        }    };// LLVM uses the address of this static member to identify the pass, so the// initialization value is unimportant.    char FunctionInfo::ID = 0;    RegisterPass<FunctionInfo> X("function-info", "15745: Function Information");}